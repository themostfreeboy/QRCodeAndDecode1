/*
des算法加密解密
Electronic Codebook (ECB)模式
消息填充模式：PKCS5Padding(88888888 @7777777 @@666666 @@@55555 @@@@4444 @@@@@333 @@@@@@22 @@@@@@@1)
密匙处理模式：基于MD5算法
*/

#pragma once

#ifndef __DES_H
#define __DES_H

#include <stdio.h>
#include "md5.h"

/*置换表*/

//对明文执行IP置换得到L0,R0 （L左32位,R右32位）               [明文操作]
const unsigned char IP_Table[64]={             
	58,50,42,34,26,18,10, 2,60,52,44,36,28,20,12, 4,
	62,54,46,38,30,22,14, 6,64,56,48,40,32,24,16, 8,
	57,49,41,33,25,17, 9, 1,59,51,43,35,27,19,11, 3,
	61,53,45,37,29,21,13, 5,63,55,47,39,31,23,15, 7 
};

//对迭代后的L16,R16执行IP逆置换,输出密文
const unsigned char IPR_Table[64]={              
	40, 8,48,16,56,24,64,32,39, 7,47,15,55,23,63,31,
	38, 6,46,14,54,22,62,30,37, 5,45,13,53,21,61,29,
	36, 4,44,12,52,20,60,28,35, 3,43,11,51,19,59,27,
	34, 2,42,10,50,18,58,26,33, 1,41, 9,49,17,57,25	
};

/*--------------------------- 迭代法则 ----------------------------*/ 

//F函数,32位的R0进行E变换,扩为48位输出 (R1~R16)        [备用A]  [明文操作]
const unsigned char E_Table[48]={
	32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9,
	 8, 9,10,11,12,13,12,13,14,15,16,17,
    16,17,18,19,20,21,20,21,22,23,24,25,
    24,25,26,27,28,29,28,29,30,31,32, 1
};

//子密钥K(i)的获取 密钥为K 抛弃第6,16,24,32,40,48,64位          [密钥操作]
//用PC1选位 分为 前28位C0,后28位D0 两部分
const unsigned char PC1_Table[56]={
	57,49,41,33,25,17, 9, 1,58,50,42,34,26,18,
	10, 2,59,51,43,35,27,19,11, 3,60,52,44,36,
	63,55,47,39,31,23,15, 7,62,54,46,38,30,22,
	14, 6,61,53,45,37,29,21,13, 5,28,20,12, 4
};

//对C0,D0分别进行左移,共16次,左移位数与下面对应                 [密钥操作]
const unsigned char Move_Table[16]={
	 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1
};

//C1,D1为第一次左移后得到,进行PC2选位,得到48位输出K1   [备用B]   [密钥操作]  
const unsigned char PC2_Table[48]={
	14,17,11,24, 1, 5, 3,28,15, 6,21,10,
	23,19,12, 4,26, 8,16, 7,27,20,13, 2,
	41,52,31,37,47,55,30,40,51,34,33,48,
	44,49,39,56,34,53,46,42,50,36,29,32	
};

/*------------- F函数 备用A和备用B 异或 得到48位输出 ---------------*/ 

//异或后的结果48位分为8组,每组6位,作为8个S盒的输入             [组合操作]
//S盒以6位作为输入(8组),4位作为输出(4*(8组)=32位)
//S工作原理 假设输入为A=abcdef ,则bcde所代表的数是0-15之间的
//一个数记为 X=bcde ,af代表的是0-3之间的一个数,记为 Y=af
//在S1的X列,Y行找到一个数Value,它在0-15之间,可以用二进制表示
//所以为4bit (共32位)
const unsigned char S_Box[8][4][16]={
	//S1
	14, 4,13, 1, 2,15,11, 8, 3,10, 6,12, 5, 9, 0, 7,
	 0,15, 7, 4,14, 2,13, 1,10, 6,12,11, 9, 5, 3, 8,
	 4, 1,14, 8,13, 6, 2,11,15,12, 9, 7, 3,10, 5, 0,
	15,12, 8, 2, 4, 9, 1, 7, 5,11, 3,14,10, 0, 6,13,
	//S2
	15, 1, 8,14, 6,11, 3, 4, 9, 7, 2,13,12, 0, 5,10,
	 3,13, 4, 7,15, 2, 8,14,12, 0, 1,10, 6, 9,11, 5,
	 0,14, 7,11,10, 4,13, 1, 5, 8,12, 6, 9, 3, 2,15,
	13, 8,10, 1, 3,15, 4, 2,11, 6, 7,12, 0, 5,14, 9,
	//S3
	10, 0, 9,14, 6, 3,15, 5, 1,13,12, 7,11, 4, 2, 8,
	13, 7, 0, 9, 3, 4, 6,10, 2, 8, 5,14,12,11,15, 1,
	13, 6, 4, 9, 8,15, 3, 0,11, 1, 2,12, 5,10,14, 7,
	 1,10,13, 0, 6, 9, 8, 7, 4,15,14, 3,11, 5, 2,12,
	//S4
	 7,13,14, 3, 0, 6, 9,10, 1, 2, 8, 5,11,12, 4,15,
	13, 8,11, 5, 6,15, 0, 3, 4, 7, 2,12, 1,10,14, 9,
	10, 6, 9, 0,12,11, 7,13,15, 1, 3,14, 5, 2, 8, 4,
	 3,15, 0, 6,10, 1,13, 8, 9, 4, 5,11,12, 7, 2,14,
	//S5
	 2,12, 4, 1, 7,10,11, 6, 8, 5, 3,15,13, 0,14, 9,
	14,11, 2,12, 4, 7,13, 1, 5, 0,15,10, 3, 9, 8, 6,
	 4, 2, 1,11,10,13, 7, 8,15, 9,12, 5, 6, 3, 0,14,
	11, 8,12, 7, 1,14, 2,13, 6,15, 0, 9,10, 4, 5, 3,
	//S6
	12, 1,10,15, 9, 2, 6, 8, 0,13, 3, 4,14, 7, 5,11,
	10,15, 4, 2, 7,12, 0, 5, 6, 1,13,14, 0,11, 3, 8,
	 9,14,15, 5, 2, 8,12, 3, 7, 0, 4,10, 1,13,11, 6,
   	 4, 3, 2,12, 9, 5,15,10,11,14, 1, 7, 6, 0, 8,13,
	//S7
	 4,11, 2,14,15, 0, 8,13, 3,12, 9, 7, 5,10, 6, 1,
	13, 0,11, 7, 4, 0, 1,10,14, 3, 5,12, 2,15, 8, 6,
	 1, 4,11,13,12, 3, 7,14,10,15, 6, 8, 0, 5, 9, 2,
	 6,11,13, 8, 1, 4,10, 7, 9, 5, 0,15,14, 2, 3,12,
	//S8
	13, 2, 8, 4, 6,15,11, 1,10, 9, 3,14, 5, 0,12, 7,
	 1,15,13, 8,10, 3, 7, 4,12, 5, 6,11, 0,14, 9, 2,
	 7,11, 4, 1, 9,12,14, 2, 0, 6,10,13,15, 3, 5, 8,
	 2, 1,14, 7, 4,10, 8,13,15,12, 9, 0, 3, 5, 6,11
};

//F函数 最后第二步,对S盒输出的32进行P置换                     [组合操作]
//输出的值参与一次迭代:
//L(i)=R(i-1)
//R(i)=L(i-1)^f(R(i-1),K(i)) 异或
const unsigned char P_Table[32]={
	16, 7,20,21,29,12,28,17, 1,15,23,26, 5,18,31,10,
	 2, 8,24,14,32,27, 3, 9,19,13,30, 6,22,11, 4,25
};

/*函数声明*/
void BitsCopy(bool *DatOut,const bool *DatIn,int Len);//数组复制

void ByteToBit(bool *DatOut,const unsigned char *DatIn,int Num);//字节到位
void BitToByte(unsigned char *DatOut,const bool *DatIn,int Num);//位到字节

void BitToHex(unsigned char *DatOut,const bool *DatIn,int Num);//二进制到十六进制 64位 to 4*16字符
void HexToBit(bool *DatOut,const unsigned char *DatIn,int Num);//十六进制到二进制

void TablePermute(bool *DatOut,const bool *DatIn,const unsigned char *Table,int Num);//位表置换函数
void LoopMove(bool *DatIn,int Len,int Num);//循环左移 Len长度 Num移动位数
void Xor(bool *DatA,const bool *DatB,int Num);// 异或函数

void S_Change(bool DatOut[32],const bool DatIn[48]);//S盒变换
void F_Change(bool DatIn[32],const bool DatKi[48]);//F函数                                

void SetKey(unsigned char KeyIn[8],bool SubKey[16][48]);//设置密钥
void PlayDes(unsigned char MesOut[8],const unsigned char MesIn[8],bool SubKey[16][48]);//执行DES加密
void KickDes(unsigned char MesOut[8],const unsigned char MesIn[8],bool SubKey[16][48]);//执行DES解密

void des_code_for64bit(const unsigned char origin_message[8], const unsigned char key[8], unsigned char coded_message[8]);//des算法加密(消息与密匙均需64位)
void des_decode_for64bit(const unsigned char origin_message[8], const unsigned char key[8], unsigned char decoded_message[8]);//des算法解密(消息与密匙均需64位)
void des_print(const unsigned char* message, int length);//以16进制形式显示加密后或解密后的信息
int des_code_foralldata(const unsigned char* origin_message, long origin_message_length, const unsigned char* key, long key_length, unsigned char* coded_message, long* coded_message_length);//des算法加密(对所有长度数据消息)
int des_decode_foralldata(const unsigned char* origin_message, long origin_message_length, const unsigned char* key, long key_length, unsigned char* decoded_message, long* decoded_message_length);//des算法解密(对所有长度数据消息)
int des_code_forallfile(const char* origin_filename, const unsigned char* key, long key_length, const char* coded_filename);//des算法加密(对所有大小文件内容)
int des_decode_forallfile(const char* origin_filename, const unsigned char* key, long key_length, const char* decoded_filename);//des算法加解密(对所有大小文件内容)
long des_MyGetFileSize(const char* filename);//获取文件大小，调用此函数时此文件必须处于未打开读写状态

#endif